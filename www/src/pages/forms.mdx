import Helmet from "react-helmet";

import Layout from '../components/layout';
import Tabs from '../../../src/modules/tabs/Tabs';
import Form from '../../../src/modules/forms/tenonForm/Form';
import Input from '../../../src/modules/forms/tenonForm/Input';
import {validator} from '../../../src/modules/utils/helpers/validationHelpers';
import {isRequired} from '../../../src/modules/utils/data/validation';

export default ({children}) => 
<Layout>
    <Helmet>
        <title>Tenon-ui | Smart form components</title>
    </Helmet>{children}
</Layout>

## Smart form components

The set of `Tenon-UI smart form components` strives to make data management, validation and 
accessibility a very manageable task in React applications.

Used together these components will:

1. Automatically manage the data entered in the form and expose that to you through submit events.
1. Provide you with an easy to manage hierarchical validation engine that allows you to easily add
your own validators and error messages.
1. Provide you with everything you need to ensure that each form and form field is accessible.

### The smart form

Instead of the standard JSX `<form>` element, use the `Form` component, imported from `Tenon.UI`.

This component employs a [children render prop](https://reactjs.org/docs/render-props.html#using-props-other-than-render)
to render the form view:

```
import React from 'react';
import { Form } from '@tenon-io/tenon-ui';
import { someSaveFunction } from './my-data-layer';

class FormClass extends React.Component {
    onSubmitHandler = formData => {
        someSaveFunction(formData);
    };

    render() {
        return (
            <Form onSubmit={this.onSubmitHandler}>
                {({ formControls, validity, hasSubmitted }) => {
                    //Your form content...
                }}
            </Form>
        );
    }
}
```

Every `Form` requires a render function supplied as children of the component. An `onSubmit`
handler is also required.

The `Form` component automatically manages all the child form element components (see below)
and will pass 

#### Form props

##### children
This prop is required.

A render function accepting three paramaters:

###### formControls
A full summary object of all form controls on the page. This object is always up to date
with the latest values from the form controls.

The structure of this object is:

```json
{
    [controlName]: {
        controlId: [autogenerated unique guid value],
        value: [current field value]
        validity: [boolean value indicating field validity],
        errorText: [string error for invalid field, otherwise '']
    },
    ...repeated for all controls on form
}

```

###### validity
A boolean value indicating the combined validity values for each form control. For `Form`s where
all the controls pass validation the value will be `true`, if at least one control fails
validation the value will be `false`.

This flag can be used to trigger global error blocks, for example.

###### hasSubmitted 
A boolean value indicating if the user has triggered a `onSubmit` event at least once.

This can also be used to display information, such as error blocks, only after the user
has attempted to submit the `Form`.

##### onSubmit
This prop is required.

An event handler function that is called in a submit event occurs and all form controls
passes validation.

**NOTE**: This event is NOT called on a submit event if any of the form controls fails
validation. Please see `onRawSubmit` below if you need this functionality.

If the `Form` is valid, the event handler is called with a `submitData` object containing
the current, valid values for each control on the `Form`, by control name:

```json
{
    [controlName]: [current control value],
    ..repeated for each control rendered on the form
}
```

##### onRawSubmit
An optional event handler that gets triggered by every submit action on the `Form`, regardless
of the validity state of the `Form`.

This event handler gets called with a `formControls` and `validity` parameter that has the same
shape and function of those injected into the view by the `Form`'s children render prop.

This function can, for example, be used to set focus on a summary error block. 

##### alwaysShowErrors
By default, the smart form control are built to only display validation error conditions once
a submit has been attempted. As this is the user experience we recommend.

Should the need arise to immediately show errors real-time , this boolean flag can be set to 
`true`.

##### className
Allows setting a `className` on the actual rendered `<form>` element.

### The smart controllers

In the `Tenon-UI smart form` architecture, each control on your `Form` will talk to this parent `Form`
automatically. Each control will also allow you to implement your own view.

In order to handle all the data management for you, as well as calculate a lot of accessibility information,
each form control type has a `smart controller component`. These controller components are part of the `Form`
compound component.

They are:
- TextInputController
- TextareaController
- SelectController
- CheckboxController
- CheckboxGroupController
- RadioGroupController

Each of these controllers also accepts a `children render prop` function where any view can be injected.

These controllers do the following for you:
- Registers itself with the `Form` component and communicates all data and validation changes.
- Provides all event handlers and data bindings required to turn your view controls into [controlled components](https://reactjs.org/docs/forms.html#controlled-components).
- Auto calculates all `id` values required for your view in order ensure that id's remain unique.
- Where possible, calculates accessibility states and properties required to make your view accessible.
- Exposes all this information via [prop getter functions](https://blog.kentcdodds.com/how-to-give-rendering-control-to-users-with-prop-getters-549eaef76acf).

Think of the controller components of where all the magic happens for each form control.

A controller is typically used as:

```
import React from 'react';
import { Form, validator } from '@tenon-io/tenon-ui';
import { someSaveFunction } from './my-data-layer';
import {
    isRequiredValidatorFunction,
    isLongerThanValidatorFunction
} from './my-validator-functions';

class FormClass extends React.Component {
    onSubmitHandler = formData => {
        someSaveFunction(formData);
    };

    render() {
        return (
            <Form onSubmit={this.onSubmitHandler}>
                {() => {
                    //Some content...
                    <Form.[Contoller]
                        name="petName"
                        required="true"
                        validators={[
                            validator(
                                isRequiredValidatorFunction,
                                'A name is required for your pet'
                            ),
                            validator(
                                isLongerThanValidatorFunction(5),
                                "Your pet's name must be longer than 5 characters"
                            )
                        ]}
                    >
                        {props => {
                            //Some view
                        }}
                    </Form.TextInputController>;
                    //Some more content
                }}
            </Form>
        );
    }
}
```

#### Controller props
Each controller has access to the same three props, although the render function of each controller differs slightly.

##### name
This prop is required.

Every controller has to have a string name. This is the name with which it will register with the `Form` component. Subsequently,
this is the name that will appear in the `Form` datasets mentioned above. 

##### required
A form control can be marked as required by acivating this prop. This is important as it then passes important information 
to the view components through the render function.

The prop accepts both `boolean` as well as `string` values.

##### validators
This array of validators forms the heart of validation in `Tenon-UI`. 

The library also exports a `validor` function you can use to compose the validators you add to the controllers. Each
entry in the `validtors` array should be composed with this function.

The function takes three parameters:

###### function 
This is the validation function to run. 

Validation functions should return `true` if the validation passes, and `false` if the validation fails.

You are free to create your own validation functions, it can even be done inline in the JSX.

Validation functions come in two forms.

The simple validation function accept a `value`, which will be injected into the function by the 
controller component. This `value` will be the current value of the control. And example of such a function
is:

```
const isRequired = value => (value && !!value.trim()) || false;
```

It is also possible to write validation functions that take a second value for comparison. For example:

```
const isLongerThan = minLength => value =>
    !value || value.length > minLength;
```

Note that these functions are `curried functions`. In the example shown above for the controller usage, it 
can be seen how each one of these types of functions are used in the validators array.

This second type of function can be used to create powerful validators between various form controls by
injecting the value of another control from `formControls` render function object into the validator of 
your control:

```
<Form onSubmit={this.onSubmitHandler}>
    {({formControls}) => {
        //Some content...
        <Form.TextInputController
            name="petName"
            required="true"
            validators={[
                validator(
                    isRequiredValidatorFunction,
                    'A name is required for your pet'
                ),
                validator(
                    isLongerThanValidatorFunction(formControls.ownerName.value.length),
                    "Your pet's name must be longer than your name"
                )
            ]}
        >
            {props => {
                //Some view
            }}
        </Form.TextInputController>;
        //Some more content
    }}
</Form>
```

The validators are executed in sequence in the order that they are defined. If a specific validator fails,
execution of validation stops, and that validator's error message is injected into the view.

This makes it possible to apply multiple validators easily, without having to deal with double error
conditions.

We will now see how each controller is used with its packaged view component and how you can write your own views.

### Text input

To create an `<input type="text">`, please use the the `TextInputController` in combination with the `Input` view component.

```
<Form.TextInputController
    name="petType"
    required="true"
    validators={[
        validator(
            isRequired,
            'A type of pet is required'
        )
    ]}
>
    {props => (
        <Input
            {...props}
            requiredText="( required )"
            labelText="Pet type"
        />
    )}
</Form.TextInputController>
```

This will render the following:

<Form
    onSubmit={submitData => {
        alert(JSON.stringyfy(submitData));
    }}
>
    {({ formControls }) => (
    <>
        <Form.TextInputController
            name="petName"
            required="true"
            validators={[
                validator(isRequired, 'A name is required for your pet')
            ]}
        >
            {props => (
                <Input
                    {...props}
                    requiredText="( required )"
                    labelText="Pet type"
                />
            )}
        </Form.TextInputController>
        <button type="submit">Submit</button>
     </>   
    )}
</Form>




