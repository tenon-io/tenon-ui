import Helmet from "react-helmet";

import Layout from '../components/layout';

export default ({children}) => 
<Layout>
    <Helmet>
        <title>Tenon-ui | Smart form element controllers</title>
    </Helmet>{children}
</Layout>

## Smart form element controllers
In the `Tenon-UI smart form` architecture, each control on your `Form` will talk to this parent `Form`
automatically. Each control will also allow you to implement your own view.

In order to handle all the data management for you, as well as calculate a lot of accessibility information,
each form control type has a `smart controller component`. These controller components are part of the `Form`
compound component.

They are:
- TextInputController
- TextareaController
- SelectController
- CheckboxController
- CheckboxGroupController
- RadioGroupController

Each of these controllers also accepts a `children render prop` function where any view can be injected.

These controllers do the following for you:
- Registers itself with the `Form` component and communicates all data and validation changes.
- Provides all event handlers and data bindings required to turn your view controls into [controlled components](https://reactjs.org/docs/forms.html#controlled-components).
- Auto calculates all `id` values required for your view in order ensure that id's remain unique.
- Where possible, calculates accessibility states and properties required to make your view accessible.
- Exposes all this information via [prop getter functions](https://blog.kentcdodds.com/how-to-give-rendering-control-to-users-with-prop-getters-549eaef76acf).

Think of the controller components of where all the magic happens for each form control.

A controller is typically used as:

```
import React from 'react';
import { Form, validator } from '@tenon-io/tenon-ui';
import { someSaveFunction } from './my-data-layer';
import {
    isRequiredValidatorFunction,
    isLongerThanValidatorFunction
} from './my-validator-functions';

class FormClass extends React.Component {
    onSubmitHandler = formData => {
        someSaveFunction(formData);
    };

    render() {
        return (
            <Form onSubmit={this.onSubmitHandler}>
                {() => {
                    //Some content...
                    <Form.[Contoller]
                        name="petName"
                        required="true"
                        validators={[
                            validator(
                                isRequiredValidatorFunction,
                                'A name is required for your pet'
                            ),
                            validator(
                                isLongerThanValidatorFunction(5),
                                "Your pet's name must be longer than 5 characters"
                            )
                        ]}
                    >
                        {props => {
                            //Some view
                        }}
                    </Form.TextInputController>;
                    //Some more content
                }}
            </Form>
        );
    }
}
```

### Controller props
Each controller has access to the same three props, although the render function of each controller differs slightly.

#### name
This prop is required.

Every controller has to have a string name. This is the name with which it will register with the `Form` component. Subsequently,
this is the name that will appear in the `Form` datasets mentioned above. 

#### required
A form control can be marked as required by acivating this prop. This is important as it then passes important information 
to the view components through the render function.

The prop accepts both `boolean` as well as `string` values.

#### validators
This array of validators forms the heart of validation in `Tenon-UI`. 

The library also exports a `validor` function you can use to compose the validators you add to the controllers. Each
entry in the `validtors` array should be composed with this function.

The function takes three parameters:

##### function 
This is the validation function to run. 

Validation functions should return `true` if the validation passes, and `false` if the validation fails.

You are free to create your own validation functions, it can even be done inline in the JSX.

Validation functions come in two forms.

The simple validation function accept a `value`, which will be injected into the function by the 
controller component. This `value` will be the current value of the control. And example of such a function
is:

```
const isRequired = value => (value && !!value.trim()) || false;
```

It is also possible to write validation functions that take a second value for comparison. For example:

```
const isLongerThan = minLength => value =>
    !value || value.length > minLength;
```

Note that these functions are `curried functions`. In the example shown above for the controller usage, it 
can be seen how each one of these types of functions are used in the validators array.

This second type of function can be used to create powerful validators between various form controls by
injecting the value of another control from `formControls` render function object into the validator of 
your control:

```
<Form onSubmit={this.onSubmitHandler}>
    {({formControls}) => {
        //Some content...
        <Form.TextInputController
            name="petName"
            required="true"
            validators={[
                validator(
                    isRequiredValidatorFunction,
                    'A name is required for your pet'
                ),
                validator(
                    isLongerThanValidatorFunction(formControls.ownerName.value.length),
                    "Your pet's name must be longer than your name"
                )
            ]}
        >
            {props => {
                //Some view
            }}
        </Form.TextInputController>;
        //Some more content
    }}
</Form>
```

The validators are executed in sequence in the order that they are defined. If a specific validator fails,
execution of validation stops, and that validator's error message is injected into the view.

This makes it possible to apply multiple validators easily, without having to deal with double error
conditions.

##### message

This is the text message to display when validations fails.

By providing it here, it gets injected into the view whenever the specific validation message should
be shown, thereby freeing the view from more decision making logic.

##### ignore

Sometimes you would like to turn off a specific validation programmatically. This third, optional
parameter, allows you to ignore any specific validator. 

To ignore a validator do:

```
validator(
    isRequiredValidatorFunction,
    'A name is required for your pet',
    true
)
```

